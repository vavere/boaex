#!/usr/bin/env python
"""SAP BusinessObject audit log extractor

Usage:
    boa-extract
    boa-extract [--uid=USERID --pwd=PASSWORD --host=HOST --dbn=DATABASE --loop=LOOP --log=LEVLE]
    boa-extract [-u USERID -p PASSWORD -h HOST -d DATABASE -l LOOP]
    boa-extract --help
    boa-extract --version

Options:
    -u USERID --uid=USERID  User name [default: dba].
    -p PASSWORD --pwd=PASSWORD  Password [default: ].
    -h HOST --host=HOST  Server host name [default: localhost].
    -d DATABASE --dbn=DATABASE  Database name [default: BI4_Audit].
    -l LOOP --loop=LOOP  Looping interval in seconds, max 3600 [default: 0].
    --log=LEVEL  Log level DEBUG, INFO, WARNING, ERROR [default: WARNING].
    --help  Show this screen.
    --version  Show version.
"""
import sys
import time
import signal
import logging
import json
import sqlanydb
from pathlib import Path
from docopt import docopt

loop_forever = True
arguments = []

def get_lastpath(): # pieņemu ka /var/lib eksistē
    logging.debug('get_lastpath()')
    boaPath = Path('/var/lib/boa-extract')
    if not boaPath.exists():
        boaPath.mkdir()
    return boaPath.joinpath('last')

def get_logpath(): # pieņemu ka /var/log eksistē
    logging.debug('get_logpath()')
    logPath = Path('/var/log/boaex.log')
    logPath.touch(exist_ok=True)
    return logPath

def get_lastid():
    logging.debug('get_lastid()')
    lastFile = get_lastpath()
    lastId = None
    if lastFile.exists():
        lastId = lastFile.read_text()
    return lastId

def set_lastid(id):
    logging.debug('set_lastid(%s)' % id)
    lastFile = get_lastpath()
    lastFile.write_text(id)

def get_conn():
    logging.debug('get_conn()')
    return sqlanydb.connect(uid=arguments['--uid'], pwd=arguments['--pwd'], host=arguments['--host'], dbn=arguments['--dbn'])

def get_curs(conn, query, params=[]):
    logging.debug('get_curs(%s, %s)' % (query, str(params)))
    curs = conn.cursor()
    curs.execute(query, params)
    return curs

def query_lastid(conn):
    logging.debug('query_lastid()')
    curs = get_curs(conn, 'select TOP 1 Start_Time from dba.ADS_EVENT order by Start_Time desc')
    row = curs.fetchone()
    if row is not None:
        lastid = row[0]
    curs.close()
    return lastid

def get_details(conn, eventId):
    logging.debug('process_details()')
    try:
        logging.debug('execute details query')
        details_query = '''
        select Event_Detail_Type_Name as Name, Event_Detail_Value as Value
        from dba.ADS_EVENT_DETAIL
        inner join dba.ADS_EVENT_DETAIL_TYPE_STR on ADS_EVENT_DETAIL_TYPE_STR.Event_Detail_Type_ID = ADS_EVENT_DETAIL.Event_Detail_Type_ID
        where Event_ID= ?
        and Language='EN'
        order by Event_Detail_Type_Name desc
        '''
        curs = get_curs(conn, details_query, [eventId])
        desc = curs.description
        rows = curs.fetchall()
        logging.debug('build details json')
        result = ''
        for row in rows:
            if result != "":
                result += ', '
            result += '{"Name": "%s", "Value": "%s"}' % (row[0], row[1])
        result = '[%s]' % result
    except Exception as e:
        logging.error(e)
        curs.close()
    else:
        return result

def action():
    try:
        logging.debug('action()')

        conn = get_conn()

        lastId = get_lastid()
        if lastId is not None:
            logging.debug('last from file %s' % lastId)
        else:
            logging.warning('Last file is empty')
            lastId = query_lastid(conn)
            logging.debug('last from table: %s' % lastId)
            if lastId is None:
                logging.warning('Event table is empty')
                return
            set_lastid(lastId)

        logPath = get_logpath()

        logging.debug('events query')
        events_query = '''select top 10
        Event_ID,Start_Time,User_Name,Object_Name,Event_Type_Name,Status_Name,Duration_ms,Sequence_In_Action
        from dba.ADS_EVENT
        inner join dba.ADS_EVENT_TYPE_STR on ADS_EVENT_TYPE_STR.Event_Type_ID = ADS_EVENT.Event_Type_ID
        inner join dba.ADS_STATUS_STR on ADS_STATUS_STR.Status_ID = ADS_EVENT.Status_ID
        where Start_Time > ?
        and ADS_EVENT_TYPE_STR.Language = 'EN'
        and ADS_STATUS_STR.Language = 'EN'
        order by Start_Time desc
        '''
        curs = get_curs(conn, events_query, [lastId])
        desc = curs.description

        count = 0
        while True:
            logging.debug('fetch one')
            row = curs.fetchone()
            if row == None:
                break
            count = count + 1

            logging.debug('build json')
            result = ""
            for col in range(len(desc)):
                if row[col] != "":
                    if result !="":
                        result += ', '
                    result += '"%s": "%s"' % (desc[col][0], row[col])
            result += ', "Details": ' + get_details(conn, row[0]) # Event_ID
            result = '{%s}\n' % result

            logging.debug('append log')
            with logPath.open('a', encoding ='utf-8') as file:
                file.write(result)
            logging.debug('save last')
            set_lastid(row[1]) # Start_Time

        logging.debug('clean up')
        curs.close()
        conn.close()
        if count > 0:
            logging.info('%s events exported' % count)
        else:
            logging.debug('no records found')

    except Exception as e:
        logging.error(e)

def handler(signum, frame):
    global loop_forever
    loop_forever = False
    logging.info('Received %s' % signal.Signals(signum).name)

signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGTERM, handler)

def main():
    logging.info('Init')
    while loop_forever:
        action()
        loop = int(arguments['--loop'])
        if not loop > 0: break
        for i in range(loop):
            time.sleep(1)
            if not loop_forever: break
    logging.info('Exit')

if __name__ == '__main__':
    arguments = docopt(__doc__, version='v1.0')
    logging.basicConfig(format='BOA: [%(levelname)s] %(message)s', level=arguments['--log'].upper())
    logging.debug(arguments)
    main()

# logger.debug('debug message')
# logger.info('info message')
# logger.warn('warn message')
# logger.error('error message')
